- Makefile qui ne relink pas comme il faut si on touche aux autres headers
(solution simple avec -MMD - MP dans les flags et -include $(OBJ:.o=.d) dans le corps du Makefile)
OK DONE

- echo echo ne repond pas echo.... 
pareil pour toutes les commandes ou le parametres est == a la commande : le parametre est skip ... 
Diagnostique du probleme : Le code skippait tout token WORD dont la valeur était égale au nom de la commande
ET quand builder->count == 1, ce qui causait le skip de tous les arguments identiques au nom de la commande.
OK DONE

- valeur de retour doit etre 2 si syntax error
OK DONE (voir parsing.c)

- Pensez a remettre a zero la valeur de retour du processe meme lors d'un 'entrer'
solution : reader return NULL, process_line recoit le NULL, return (0)directement.
OK DONE (voir reader.c/ main.c)

signaux CTRL+D sur empty prompt -> la valeur de retour doit etre 0
OK DONE
(voir reader.c)
ctrl-C in an empty prompt -> valeur de retour doit etre 130
OK DONE
(voir main.c)

exit 242 => code de sortie incorrecte 
Attention a quand vous allez corrigier a bien mettre la valeur en unsigned (entre 0 et 255) et
faire les modif pour avoir le bon retour de process enfant dans la fonction wait (test avec sigfault = 139).
OK DONE (voir exec_utils.c)

Trouver comment afficher le message d'erreur du segflaut dans process enfant
EXEMPLE :
Minishell> ./test_segfault
Ce programme va volontairement segfault...
Minishell> echo $?
139
-> bon retour d'erreur mais pas de message
cause :
   Absence de messages d'erreur pour SIGSEGV

Solution : Ajout de l'affichage des messages dans waiting() pour SIGSEGV
-> Affiche maintenant "Segmentation fault" et retourne 139
Ok DONE

Try ctrl-\ after running a blocking command like cat without arguments -> 
afficher "^\Quit (core dumped)"
$ echo $?
131"
cause :
le signal SIGQUIT (envoyé par ctrl-) était ignoré partout, y compris dans le processus enfant (ex : cat). 
solution : 
Il faut rétablir le comportement par défaut de SIGQUIT dans le processus enfant juste avant d’exécuter la commande.
OK DONE

exit 'alpha' -> code de sortie incorrecte & message d'erreur manquant
cause : 
la fonction ne quittait pas correctement avec le bon code après une erreur d’argument non numérique (voir ft_exit.c) 
solution : 
quitter minishell avec le code de sortie 2 (free_all(data, 2, NULL)) quand l’argument n’est pas numérique,
Libère la mémoire
Termine le programme avec le code de sortie donné ( 2)



echo -nnnnnnnnnnn 
cause : manquait parsing de -nnnnn
OK DONE
